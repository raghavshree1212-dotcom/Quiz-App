import { db } from './firebaseConfig';
import { 
  collection, 
  addDoc, 
  getDocs, 
  doc, 
  setDoc, 
  getDoc, 
  updateDoc, 
  arrayUnion, 
  arrayRemove,
  query,
  where
} from 'firebase/firestore';
import { Question, QuizResult } from '../types';

// Collection Names
const COL_QUESTIONS = 'questions';
const COL_USERS = 'users';

// Local Storage Keys for Guest/Fallback Mode
const LS_GUEST_DATA = 'quiz_guest_data';
const LS_LOCAL_QUESTIONS = 'quiz_local_questions';

const getGuestData = () => {
  try {
    return JSON.parse(localStorage.getItem(LS_GUEST_DATA) || '{"bookmarks": [], "results": []}');
  } catch { return { bookmarks: [], results: [] }; }
};

const saveGuestData = (data: any) => localStorage.setItem(LS_GUEST_DATA, JSON.stringify(data));

const getLocalQuestions = (): Question[] => {
  try {
    return JSON.parse(localStorage.getItem(LS_LOCAL_QUESTIONS) || '[]');
  } catch { return []; }
};

const addLocalQuestions = (newQuestions: Question[]) => {
  const current = getLocalQuestions();
  localStorage.setItem(LS_LOCAL_QUESTIONS, JSON.stringify([...current, ...newQuestions]));
};

export const storageService = {
  // --- Public Questions ---
  async getQuestions(): Promise<Question[]> {
    let firestoreQuestions: Question[] = [];
    try {
      const querySnapshot = await getDocs(collection(db, COL_QUESTIONS));
      firestoreQuestions = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Question));
    } catch (error) {
      console.warn("Firestore access failed (likely domain restriction). Using fallback data.", error);
      // Fallback questions to ensure app is usable in preview without config
      firestoreQuestions = [
        {
          id: 'fallback-1',
          text: 'Which planet is known as the Red Planet?',
          options: ['Earth', 'Mars', 'Jupiter', 'Venus'],
          correctAnswer: 'Mars',
          topic: 'Astronomy',
          subject: 'Science'
        },
        {
          id: 'fallback-2',
          text: 'What is the largest mammal in the world?',
          options: ['African Elephant', 'Blue Whale', 'Giraffe', 'Hippopotamus'],
          correctAnswer: 'Blue Whale',
          topic: 'Biology',
          subject: 'Science'
        },
        {
          id: 'fallback-3',
          text: 'What is the primary function of React useEffect?',
          options: ['Handle side effects', 'Update state', 'Create components', 'Route pages'],
          correctAnswer: 'Handle side effects',
          topic: 'React',
          subject: 'Programming'
        }
      ];
    }

    // Merge with local questions (generated by Guest)
    const localQuestions = getLocalQuestions();
    // De-duplicate by ID
    const all = [...firestoreQuestions, ...localQuestions];
    const unique = Array.from(new Map(all.map(item => [item.id, item])).values());
    return unique;
  },

  async addQuestions(questions: Question[]): Promise<void> {
    try {
      const existingRef = await getDocs(collection(db, COL_QUESTIONS));
      const existingTexts = new Set(existingRef.docs.map(d => (d.data() as Question).text.toLowerCase().trim()));

      const batchPromises = questions.map(async (q) => {
        if (!existingTexts.has(q.text.toLowerCase().trim())) {
          const { id, ...data } = q; 
          await addDoc(collection(db, COL_QUESTIONS), data);
        }
      });
      await Promise.all(batchPromises);
    } catch (error) {
      console.warn("Error adding questions to Firestore (likely permissions). Saving locally.", error);
      addLocalQuestions(questions);
    }
  },

  async getTopics(): Promise<string[]> {
    const questions = await this.getQuestions();
    const topics = new Set<string>(questions.map(q => q.topic));
    return Array.from(topics);
  },

  // --- User Data ---
  
  // Helper to ensure user document exists
  async ensureUserDoc(userId: string) {
    if (userId.startsWith('guest_')) return;
    try {
      const userRef = doc(db, COL_USERS, userId);
      const snap = await getDoc(userRef);
      if (!snap.exists()) {
        await setDoc(userRef, { createdAt: Date.now() });
      }
    } catch (e) {
      console.warn("Failed to ensure user doc", e);
    }
  },

  async getUserBookmarks(userId: string): Promise<string[]> {
    if (userId.startsWith('guest_')) {
      return getGuestData().bookmarks;
    }
    try {
      const ref = doc(db, COL_USERS, userId, 'userData', 'bookmarks');
      const snap = await getDoc(ref);
      if (snap.exists()) {
        return snap.data().ids || [];
      }
      return [];
    } catch (error) {
      console.error("Error getting bookmarks:", error);
      return [];
    }
  },

  async toggleBookmark(userId: string, questionId: string): Promise<boolean> {
    if (userId.startsWith('guest_')) {
      const data = getGuestData();
      const set = new Set(data.bookmarks);
      let isAdded = false;
      if (set.has(questionId)) {
        set.delete(questionId);
      } else {
        set.add(questionId);
        isAdded = true;
      }
      data.bookmarks = Array.from(set);
      saveGuestData(data);
      return isAdded;
    }

    try {
      await this.ensureUserDoc(userId);
      const ref = doc(db, COL_USERS, userId, 'userData', 'bookmarks');
      const snap = await getDoc(ref);
      
      let currentIds: string[] = [];
      if (snap.exists()) {
        currentIds = snap.data().ids || [];
      } else {
        await setDoc(ref, { ids: [] });
      }

      const isBookmarked = currentIds.includes(questionId);

      if (isBookmarked) {
        await updateDoc(ref, {
          ids: arrayRemove(questionId)
        });
        return false;
      } else {
        await updateDoc(ref, {
          ids: arrayUnion(questionId)
        });
        return true;
      }
    } catch (error) {
      console.error("Error toggling bookmark:", error);
      return false;
    }
  },

  async saveQuizResult(userId: string, result: QuizResult): Promise<void> {
    if (userId.startsWith('guest_')) {
      const data = getGuestData();
      const results = data.results || [];
      results.push(result);
      data.results = results;
      saveGuestData(data);
      return;
    }

    try {
      await this.ensureUserDoc(userId);
      const resultsRef = collection(db, COL_USERS, userId, 'results');
      const { id, ...data } = result;
      await addDoc(resultsRef, data);
    } catch (error) {
      console.error("Error saving result:", error);
    }
  },

  async getQuizHistory(userId: string): Promise<QuizResult[]> {
    if (userId.startsWith('guest_')) {
       const data = getGuestData();
       return (data.results || []).sort((a: any, b: any) => b.timestamp - a.timestamp);
    }

    try {
      const resultsRef = collection(db, COL_USERS, userId, 'results');
      const snap = await getDocs(resultsRef);
      // Sort by timestamp descending in memory (or use query orderBy if index exists)
      const results = snap.docs.map(doc => ({ id: doc.id, ...doc.data() } as QuizResult));
      return results.sort((a, b) => b.timestamp - a.timestamp);
    } catch (error) {
      console.error("Error getting history:", error);
      return [];
    }
  },
  
  async getQuestionsByIds(ids: string[]): Promise<Question[]> {
    const all = await this.getQuestions();
    const idSet = new Set(ids);
    return all.filter(q => idSet.has(q.id));
  }
};